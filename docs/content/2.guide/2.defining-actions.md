---
title: Defining Actions
description: Learn how to define server actions with validation and handlers.
---

# Defining Actions

Actions are defined in `server/actions/` and default-exported. Each file becomes an action that can be imported on the client.

## Basic Action

```ts [server/actions/greet.ts]
import { z } from 'zod'
import { actionClient } from '../utils/action-client'

export default actionClient
  .schema(z.object({
    name: z.string().min(1, 'Name is required'),
  }))
  .action(async ({ parsedInput }) => {
    return { greeting: `Hello, ${parsedInput.name}!` }
  })
```

## File Conventions

- Actions live in `server/actions/` (configurable via `safeAction.actionsDir`)
- Each file must **default-export** an action
- The file name becomes the import name (kebab-case is converted to camelCase)

| File | Import Name |
|------|-------------|
| `server/actions/greet.ts` | `greet` |
| `server/actions/create-post.ts` | `createPost` |
| `server/actions/get-user-profile.ts` | `getUserProfile` |

## With Validation

Use `.schema()` to validate input with Zod before the handler runs:

```ts [server/actions/create-post.ts]
import { z } from 'zod'
import { actionClient } from '../utils/action-client'

export default actionClient
  .schema(z.object({
    title: z.string().min(1, 'Title is required').max(200),
    body: z.string().min(1, 'Body is required'),
    tags: z.array(z.string()).optional(),
  }))
  .action(async ({ parsedInput }) => {
    const post = await db.post.create({ data: parsedInput })
    return { id: post.id, title: post.title }
  })
```

If validation fails, the errors are returned as `validationErrors` on the client â€” no exception is thrown.

## With Output Validation

Use `.outputSchema()` to validate the return value of your action:

```ts [server/actions/get-user.ts]
import { z } from 'zod'
import { actionClient } from '../utils/action-client'

export default actionClient
  .schema(z.object({ id: z.string() }))
  .outputSchema(z.object({
    name: z.string(),
    email: z.string().email(),
  }))
  .action(async ({ parsedInput }) => {
    const user = await db.user.findUnique({ where: { id: parsedInput.id } })
    return { name: user.name, email: user.email }
  })
```

## With Metadata

Attach metadata to actions that middleware can read:

```ts [server/actions/admin-action.ts]
import { z } from 'zod'
import { actionClient } from '../utils/action-client'

export default actionClient
  .metadata({ requiredRole: 'admin' })
  .schema(z.object({ userId: z.string() }))
  .action(async ({ parsedInput }) => {
    // Only runs if middleware allows it
    await db.user.delete({ where: { id: parsedInput.userId } })
    return { deleted: true }
  })
```

## Without Validation

If your action doesn't need input, skip `.schema()`:

```ts [server/actions/get-stats.ts]
import { actionClient } from '../utils/action-client'

export default actionClient
  .action(async () => {
    const count = await db.user.count()
    return { userCount: count }
  })
```
